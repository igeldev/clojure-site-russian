= Считыватель
Rich Hickey
2015-01-01
:jbake-type: page
:toc: macro
:toc-title: Содержание

ifdef::env-github,env-browser[:outfilesuffix: .adoc]

toc::[]

== Считыватель

Clojure является http://en.wikipedia.org/wiki/Homoiconicity[гомоиконным] языком. Этот причудливый термин означает, что программы на Clojure представлены в виде структур данных Clojure. Это очень важное отличие между Clojure (и Common Lisp) и большинством других языков программирования - Clojure определена в терминах вычисления структур данных, а *не* с точки зрения синтаксиса потоков символов или файлов. Для Clojure-программ довольно распространено и просто оперировать, модифицировать и генерировать другие Clojure-программы.

Тем не менее, большинство Clojure-программ создаются в виде текстовых файлов, и задачей _считывателя_ является преобразование текста в структуры данных, которые уже увидит компилятор. То есть это не просто фаза компиляции. И считыватель, и представление данных Clojure, полезны сами по себе для решения многих задач, где можно использовать XML, JSON и т.п.

Можно сказать, что у считывателя есть синтаксис, определенный в терминах символов, а синтаксис языка Clojure определяется в терминах знаков, списков, векторов, ассоциативных массивов и т.д. Считыватель представлен функцией http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/read[read], которая считывает следующую форму (не символ) из потока и возвращает объект представляемый этой формой.

Так как нужно с чего-то начать, этот справочник начинается там же, где начинается вычисление - с форм считывателя. Это неизбежно повлечет за собой разговор о структурах данных, а затем об их описательных способностях и интерпретации компилятором.

=== Формы считывателя

* Знаки
** Знаки состоят из букв, цифр, а также символов *, +, !, -, _, ' и ? (со временем могут быть разрешены и другие символы) и не могут начинаться с цифры. 
** '/' имеет специальное значение - он может быть использован только однажды в середине знака для того, чтобы отделить <<namespaces#,пространство имен>> от имени, например: `my-namespace/foo`. '/' сам по себе также является именем функции деления. 
** '.' имеет специальное значение - он может быть использован один или более раз в середине знака, чтобы указать полное имя класса, например: `java.util.BitSet`, или в пространстве имен. Знаки, начинающиеся с '.' зарезервированы Clojure. Знаки, содержащие '/' или '.', именуются 'уточненными'. 
** Знаки, начинающиеся или заканчивающиеся ':' зарезервированы Clojure. Знак может содержать один или более не повторяющихся ':'. 
* Литералы
** Строки - обрамлены в "двойные кавычки". Могут охватывать несколько строк. Поддерживаются стандартные символы экранирования Java.
** Числа - представляются почти как в Java
*** Целые числа могут быть неограничено длинными и будут прочитаны как Long или как clojure.lang.BigInt в зависимости от размера. Целые числа с суффиксом N всегда прочитываются как BigInt. Когда возможно, они могут быть заданы в любой системе счисления от 2 до 36 (см. http://docs.oracle.com/javase/7/docs/api/java/lang/Long.html#parseLong(java.lang.String,%20int)[Long.parseLong()]); например 2r101010, 8r52, 36r16 и 42 - все являются Long.
*** Числа с плавающей запятой прочитываются как Double; с суффиксом M - как BigDecimal.
*** Поддерживаются дроби, например: 22/7.
** Символы - начинаются с обратной косой черты: \c. \newline, \space, \tab, \formfeed, \backspace и \return производят соответствующие символы. Символы Юникода записываются \uNNNN, как в Java. Окталы записываются \oNNN.
** nil означает "ничего", "нет значения" - соответствует null в Java и логическому false.
** Логические - true и false.
** Ключевые слова - как знаки, за изключением:
*** Они могут и должны начинаться с ':', например :fred.
*** Они не могут содержать '.' или имена классов.
*** Ключевое слово, начинающееся с двух двоеточий соответствует текущему пространству имен:
**** В пространстве имен user, '::rect' прочитывается как `:user/rect`
* Списки
+
Списки - ноль или более форм, заключенных в скобки: `(a b c)`

* Вектора
+
Вектора - ноль или более форм, заключенных в квадратные скобки: `[1 2 3]`
* Ассоциативные массивы
+
Ассоциативный массив - ноль или более пар ключ-значение, заключенных в фигурные скобки: `{:a 1 :b 2}` +
Запятые рассматриваются как пробельный символ и могут быть использованы для огранизации пар: `{:a 1, :b 2}` +
В качестве ключей и значений могут выступать любые формы.
* Множества
+
Множества - ноль или более форм, заключенных в фигурные скобки и начинающиеся с `pass:[#]`: `#{:a :b :c}`
* deftype, defrecord и вызовы конструкторов (версия 1.3 и выше):
+
Вызовы конструкторов Java классов, deftype и defrecord могут быть выполнены с использованием полного имени класса с # перед ним и вектором после: `#my.klass_or_type_or_record[:a :b :c]` +
Элементы в векторе передаются "невычисленными" в соответствующий конструктор. Экземпляры defrecord также могут быть созданы похожим образом, с использованием ассоциативного массива вместо вектора: `#my.record{:a 1, :b 2}` +
Значения, ассоциированные с ключами, передаются "невычисленными" в соответствующие поля defrecord. Всем полям defrecord, которым не соответствует пара ключ-значение, будет присвоено значение nil. Дополнительные пары ключ-значение будут добавлены в конструируемый экземпляр defrecord.

[[macrochars]]
=== Macro characters

The behavior of the reader is driven by a combination of built-in constructs and an extension system called the read table. Entries in the read table provide mappings from certain characters, called macro characters, to specific reading behavior, called reader macros. Unless indicated otherwise, macro characters cannot be used in user symbols.

* Quote (')
+
`'form` => `(quote form)`
* Character (\)
+
As per above, yields a character literal.
* Comment (;)
+
Single-line comment, causes the reader to ignore everything from the semicolon to the end-of-line.
* Deref (@)
+
`@form => (deref form)`
* Metadata (^)
+
Metadata is a map associated with some kinds of objects: Symbols, Lists, Vector, Sets, Maps, tagged literals returning an IMeta, and record, type, and constructor calls. The metadata reader macro first reads the metadata and attaches it to the next form read (see http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/with-meta[with-meta] to attach meta to an object): +
`^{:a 1 :b 2} [1 2 3]` yields the vector `[1 2 3]` with a metadata map of `{:a 1 :b 2}`. +
+
A shorthand version allows the metadata to be a simple symbol or string, in which case it is treated as a single entry map with a key of :tag and a value of the (resolved) symbol or string, e.g.: +
`^String x` is the same as `^{:tag java.lang.String} x` +
Such tags can be used to convey type information to the compiler. +
+
Another shorthand version allows the metadata to be a keyword, in which case it is treated as a single entry map with a key of the keyword and a value of true, e.g.: +
`^:dynamic x` is the same as `^{:dynamic true} x` +
+
Metadata can be chained in which case they are merged from right to left.
* Dispatch (pass:[#])
+
The dispatch macro causes the reader to use a reader macro from another table, indexed by the character following

** pass:[#{}] - see Sets above
** Regex patterns (pass:[#"pattern"])
+
A regex pattern is read and _compiled at read time_. The resulting object is of type java.util.regex.Pattern. Regex strings do not follow the same escape character rules as strings. Specifically, backslashes in the pattern are treated as themselves (and do not need to be escaped with an additional backslash). For example, `(re-pattern "\\s*\\d+")` can be written more concisely as `#"\s*\d+"`.
** Var-quote (pass:[#'])
+
`#'x` => `(var x)`
** Anonymous function literal (#())
+
`#(...)` => `(fn [args] (...))` +
where args are determined by the presence of argument literals taking the form %, %n or %&. % is a synonym for %1, %n designates the nth arg (1-based), and %& designates a rest arg. This is not a replacement for http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/fn[fn] - idiomatic use would be for very short one-off mapping/filter fns and the like. #() forms cannot be nested.
** Ignore next form (pass:[#_])
+
The form following pass:[#_] is completely skipped by the reader. (This is a more complete removal than the http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/comment[comment] macro which yields nil).

* [[syntax-quote]] Syntax-quote (`, note, the "backquote" character), Unquote (~) and Unquote-splicing (~@)
+
For all forms other than Symbols, Lists, Vectors, Sets and Maps, `x is the same as 'x. +
+
For Symbols, syntax-quote _resolves_ the symbol in the current context, yielding a fully-qualified symbol (i.e. namespace/name or fully.qualified.Classname). If a symbol is non-namespace-qualified and ends with pass:['#'], it is resolved to a generated symbol with the same name to which '_' and a unique id have been appended. e.g. x# will resolve to x_123. All references to that symbol within a syntax-quoted expression resolve to the same generated symbol. +
+
For Lists/Vectors/Sets/Maps, syntax-quote establishes a template of the corresponding data structure. Within the template, unqualified forms behave as if recursively syntax-quoted, but forms can be exempted from such recursive quoting by qualifying them with unquote or unquote-splicing, in which case they will be treated as expressions and be replaced in the template by their value, or sequence of values, respectively. +
+
For example: +
+
[source,clojure]
----
    user=> (def x 5)
    user=> (def lst '(a b c))
    user=> `(fred x ~x lst ~@lst 7 8 :nine)
    (user/fred user/x 5 user/lst a b c 7 8 :nine)
----
+
The read table is currently not accessible to user programs.

=== extensible data notation (edn) 
Clojure's reader supports a superset of https://github.com/edn-format/edn[extensible data notation (edn)]. The edn specification is under active development, and complements this document by defining a subset of Clojure data syntax in a language-neutral way.

=== Tagged Literals 
Tagged literals are Clojure's implementation of edn https://github.com/edn-format/edn#tagged-elements[tagged elements].

When Clojure starts, it searches for files named `data_readers.clj` at the root of the classpath. Each such file must contain a Clojure map of symbols, like this:
[source,clojure]
----
    {foo/bar my.project.foo/bar
     foo/baz my.project/baz}
----
The key in each pair is a tag that will be recognized by the Clojure reader. The value in the pair is the fully-qualified name of a <<vars#,Var>> which will be invoked by the reader to parse the form following the tag. For example, given the data_readers.clj file above, the Clojure reader would parse this form:
[source,clojure]
----
    #foo/bar [1 2 3]
----
by invoking the Var `#'my.project.foo/bar` on the vector `[1 2 3]`. The data reader function is invoked on the form AFTER it has been read as a normal Clojure data structure by the reader.

Reader tags without namespace qualifiers are reserved for Clojure. Default reader tags are defined in http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/default-data-readers[default-data-readers] but may be overridden in `data_readers.clj` or by rebinding http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/%2Adata-readers%2A[pass:[*data-readers*]]. If no data reader is found for a tag, the function bound in http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/%2Adefault-data-reader-fn%2A[pass:[*default-data-reader-fn*]] will be invoked with the tag and value to produce a value. If pass:[*default-data-reader-fn*] is nil (the default), a RuntimeException will be thrown.

=== Reader Conditionals
 
Clojure 1.7 introduced a new extension (.cljc) for portable files that can be loaded by multiple Clojure platforms. The primary mechanism for managing platform-specific code is to isolate that code into a minimal set of namespaces, and then provide platform-specific versions (.clj/.class or .cljs) of those namespaces.

In cases where is not feasible to isolate the varying parts of the code, or where the code is mostly portable with only small platform-specific parts, 1.7 also introduced _reader conditionals_, which are supported only in cljc files and at the default REPL. Reader conditionals should be used sparingly and only when necessary.

Reader conditionals are a new reader dispatch form starting with `pass:[#?]` or `pass:[#?@]`. Both consist of a series of alternating features and expressions, similar to `cond`. Every Clojure platform has a well-known "platform feature" - `:clj`, `:cljs`, `:cljr`. Each condition in a reader conditional is checked in order until a feature matching the platform feature is found. The reader conditional will read and return that feature's expression. The expression on each non-selected branch will be read but skipped. A well-known `:default` feature will always match and can be used to provide a default. If no branches match, no form will be read (as if no reader conditional expression was present).

The following example will read as Double/NaN in Clojure, js/NaN in ClojureScript, and nil in any other platform:

[source,clojure]
----
#?(:clj     Double/NaN
   :cljs    js/NaN
   :default nil)
----

The syntax for `pass:[#?@]` is exactly the same but the expression is expected to return a collection that can be spliced into the surrounding context, similar to unquote-splicing in syntax quote. Use of reader conditional splicing at the top level is not supported and will throw an exception. An example:

[source,clojure]
----
[1 2 #?@(:clj [3 4] :cljs [5 6])]
;; in clj =>        [1 2 3 4]
;; in cljs =>       [1 2 5 6]
;; anywhere else => [1 2]
----

The http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/read[read] and http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/read-string[read-string] functions optionally take a map of options as a first argument. The current feature set and reader conditional behavior can be set in the options map with these keys and values:

[source,clojure]
----
  :read-cond - :allow to process reader conditionals, or
               :preserve to keep all branches
  :features - persistent set of feature keywords that are active
----

An example of how to test ClojureScript reader conditionals from Clojure:

[source,clojure]
----
(read-string 
  {:read-cond :allow 
   :features #{:cljs}} 
  "#?(:cljs :works! :default :boo)")
;; :works!
----

However, note that the Clojure reader will _always_ inject the platform feature :clj as well. For platform-agnostic reading, see https://github.com/clojure/tools.reader[tools.reader].

If the reader is invoked with `{:read-cond :preserve}`, the reader conditional and non-executed branches will be preserved, as data, in the returned form. The reader-conditional will be returned as a type that supports keyword retrieval for keys with `:form` and a `:splicing?` flag. Read but skipped tagged literals will be returned as a type that supports keyword retrieval for keys with `:form` and `:tag` keys.

[source,clojure]
----
(read-string 
  {:read-cond :preserve} 
  "[1 2 #?@(:clj [3 4] :cljs [5 6])]")
;; [1 2 #?@(:clj [3 4] :cljs [5 6])]
----

The following functions can also be used as predicates or constructors for these types: +
http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/reader-conditional%3F[reader-conditional?] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/reader-conditional[reader-conditional] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/tagged-literal%3F[tagged-literal?] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/tagged-literal[tagged-literal]
