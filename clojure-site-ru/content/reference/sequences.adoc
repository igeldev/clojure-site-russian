= Последовательности
Rich Hickey
2015-01-01
:type: reference
:toc: macro
:toc-title: Содержание
:icons: font
:prevpagehref: datatypes
:prevpagetitle: Datatypes
:nextpagehref: transients
:nextpagetitle: Transients

ifdef::env-github,env-browser[:outfilesuffix: .adoc]

toc::[]

Clojure определяет множество алгоритмов в терминах последовательностей. Последовательность - это логический список, но в отличие от большинства диалектов Lisp, где список представляется конкретной 2-х-слотовой структурой Clojure использует интерфейс ISeq, чтобы позволить множеству структур данных предоставлять доступ к своим элементам как к последовательностям. Функция http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/seq[seq] порождает реализацию ISeq, подходящую входной коллекции. Последовательности отличаются от итераторов тем, что они являются постоянными и неизменяемыми, не имеющими внутреннего состояния указателями в коллекции. По существу, они более полезны, чем оператор foreach - функции могут возвращать последовательности и принимать их в качестве аргументов, они потокобезопасны, могут работать с одной и той же структурой и т.д.

Большинство библиотечных функций последовательностей - _ленивые_, т.е. функции, которые возвращают последовательности делают это пошагово, когда они потребляются, а также потребляют аргумент-последовательность пошагово. Функции, возвращающие ленивые последовательности могут быть реализованы с помощью макроса http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/lazy-seq[lazy-seq]. См. также <<lazy#,леность>>.

Когда функция http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/seq[seq] используется на объектах, которые реализуют интерфейс Iterable, получаемые последовательности будут по прежнему неизменяемыми и постоянными, и будут представлять единичный проход по данным. Так как этот проход может быть осуществлен лениво, проход может увидеть изменения, случившиеся после вызова http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/seq[seq]. Также, если исходный итератор может выбросить ConcurrentModificationException, тоже самое может сделать и последовательность. Когда функция seq используется на массивах Java, изменения в исходном массиве будут отражены в последовательности - чтобы получить действительную неизменяемость вы должны скопировать исходный массив. Таким образом, есть польза от использования функции seq на экземплярах Iterable и массивах так как последовательности поддерживают многоходовые и ленивые алгоритмы. Хорошие программы не должны изменять массивы или экземпляры Iterable, на основе которых была создана последовательность.

Множество библиотечных функций последовательностей принимают одну или более коллекций, вызывают http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/seq[seq] на них, и затем оперируют с полученными последовательностями. Другими словами, многие из этих функций принимают коллекции, но оперируют с последовательностями.

== Интерфейс Seq

=== (_first_ coll)
Возвращает первый элемент в коллекции. Вызывает функцию seq на своем аргументе. Если аргумент равен nil, возвращает nil.

=== (_rest_ coll)
Возвращает последовательность элементов, следующих за первым. Вызывает функцию seq на своем аргументе. Если после первого элементов больше нет, возвращает логическую последовательность, для которой *seq* возвращает nil.

=== (_cons_ item seq)
Возвращает новую поелсдовательность, где первый элемент будет item, а затем будут идти элементы последовательности seq.

Сравнение *rest*, *next* и *lazy-seq* см. разделе <<lazy#,леность>>

== The Seq library

This is a sampling of the primary sequence functions, grouped broadly by their capabilities. Some functions can be used in different ways and so appear in more than one group. There are many more listed in the http://clojure.github.io/clojure/[API] section.

Since Clojure 1.7, Clojure also provides <<transducers#,transducers>>, an alternate model for composable transformations on collections. Transducers decouple the input, processing, and output parts of transformation and allow reuse of transformations in more contexts, such as core.async channels. Many of the sequence functions in the list below will create transducers if the input collection is omitted. See the Transducers page for more details.

=== Seq in, Seq out

[%hardbreaks]
Shorter seq from a longer seq: http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/distinct[distinct] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/filter[filter] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/remove[remove] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/for[for] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/keep[keep] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/keep-indexed[keep-indexed]
Longer seq from a shorter seq: http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/cons[cons] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/concat[concat] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/lazy-cat[lazy-cat] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/mapcat[mapcat] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/cycle[cycle] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/interleave[interleave] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/interpose[interpose]
Seq with head-items missing: http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/rest[rest] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/next[next] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/fnext[fnext] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/nnext[nnext] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/drop[drop] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/drop-while[drop-while] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/nthnext[nthnext] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/for[for]
Seq with tail-items missing: http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/take[take] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/take-nth[take-nth] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/take-while[take-while] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/butlast[butlast] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/drop-last[drop-last] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/for[for]
Rearrangment of a seq: http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/flatten[flatten] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/reverse[reverse] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/sort[sort] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/sort-by[sort-by] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/shuffle[shuffle]
Create nested seqs: http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/split-at[split-at] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/split-with[split-with] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/partition[partition] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/partition-all[partition-all] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/partition-by[partition-by]
Process each item of a seq to create a new seq: http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/map[map] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/pmap[pmap] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/mapcat[mapcat] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/for[for] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/replace[replace] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/reductions[reductions] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/map-indexed[map-indexed] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/seque[seque]

=== Using a seq

[%hardbreaks]
Extract a specific-numbered item from a seq: http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/first[first] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/ffirst[ffirst] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/nfirst[nfirst] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/second[second] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/nth[nth] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/when-first[when-first] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/last[last] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/rand-nth[rand-nth]
Construct a collection from a seq: http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/zipmap[zipmap] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/into[into] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/reduce[reduce] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/set[set] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/vec[vec] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/into-array[into-array] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/to-array-2d[to-array-2d] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/frequencies[frequencies] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/group-by[group-by]
Pass items of a seq as arguments to a function: http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/apply[apply]
Compute a boolean from a seq: http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/not-empty[not-empty] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/some[some] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/reduce[reduce] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/seq?[seq?] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/every?[every?] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/not-every?[not-every?] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/not-any?[not-any?] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/empty?[empty?]
Search a seq using a predicate: http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/some[some] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/filter[filter]
Force evaluation of lazy seqs: http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/doseq[doseq] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/dorun[dorun] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/doall[doall]
Check if lazy seqs have been forcibly evaluated: http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/realized?[realized?]

=== Creating a seq

[%hardbreaks]
Lazy seq from collection: http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/seq[seq] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/vals[vals] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/keys[keys] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/rseq[rseq] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/subseq[subseq] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/rsubseq[rsubseq]
Lazy seq from producer function: http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/lazy-seq[lazy-seq] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/repeatedly[repeatedly] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/iterate[iterate]
Lazy seq from constant: http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/repeat[repeat] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/range[range]
Lazy seq from other objects: http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/line-seq[line-seq] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/resultset-seq[resultset-seq] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/re-seq[re-seq] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/tree-seq[tree-seq] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/file-seq[file-seq] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/xml-seq[xml-seq] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/iterator-seq[iterator-seq] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/enumeration-seq[enumeration-seq]
