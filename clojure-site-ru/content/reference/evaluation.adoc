= Вычисление
Rich Hickey
2015-01-01
:type: reference
:toc: macro
:toc-title: Содержание
:icons: font
:prevpagehref: repl_and_main
:prevpagetitle: REPL and main
:nextpagehref: special_forms
:nextpagetitle: Special Forms

ifdef::env-github,env-browser[:outfilesuffix: .adoc]

Вычисление может происходить в различных контекстах:

* Интерактивно, в REPL
* На последовательности чтения форм из потока, с помощью `load` / `load-file` / `load-reader` / `load-string`
* Программно, с помощью `eval`

Программы Clojure состоят из выражений. Каждая форма, не обработанная специально какой-либо специальной формой или макросом, рассматривается компилятором как выражение, которое вычисляется чтобы получить значение. Нет объявлений или операторов, хотя иногда выражения могут быть вычилены из-за побочных эффектов и их значение игнорируется.
В любом случае, при вычислении один объект рассматривается компилятором, вычисляется и его результат возвращается. Если нужно скомпилировать выражение, это будет сделано. Нет отдельных этапов компиляции и нет необходимости быспокоиться что функция, которую вы определили будет проинтерпретирована. _Clojure не имеет интерпретатора_.

Строки, числа, символы, `true`, `false`, `nil` и ключевые значения вычисляются в самих себя.

Знаки _разрешаются_:

* Если это знак с уточненным пространством имен, его значение - это значение глобальной переменной называемой этим символом. Если такой переменной не существует или она существует, но не является публичной или принадлежит к другому пространству имен - это ошибка.
* Если это знак с уточненным пакетом, его значение - это Java класс назваемый символом. Если такого класса нет - это ошибка.
* Иначе, если знак не уточнен и первое из следующего применимо:
. Если он называет специальную форму, то он рассматривает специальную форму и должен быть соответственно использован.
. Поиск выполняется в текущем пространстве имен чтобы найти есть ли соответствие от знака к классу. Если так, знак рассматривается как имя Java объект. Кстати, имена классов обычно обозначают объекты Class, но обрабатываются специальным образом в некоторой специальной форме, например `.` и `new`.
. Если локально (т.е. в определении функции), поиск выполняется, чтобы найти если знак именует локальную переменную (например, аргумент функции). Если так, значение - это значение локальной переменной.
. Поиск выполняется в текущем пространстве имен и ищется, есть ли соответствие знака и переменной. Если так, значение - это значение привязанное к этой переменной.
. Иначе это ошибка.

If a Symbol has metadata, it may be used by the compiler, but will not be part of the resulting value.

Vectors, Sets and Maps yield vectors and (hash) sets and maps whose contents are the _evaluated values_ of the objects they contain. Vector elements are evaluated left to right, Sets and Maps are evaluated in an undefined order. The same is true of metadata maps. If the vector or map has metadata, the _evaluated_ metadata map will become the metadata of the resulting value.

[source,clojure-repl]
----
user=> (def x 1)
user=> (def y 2)
user=> ^{:x x} [x y 3]
^{:x 1} [1 2 3]
----

An empty list `()` evaluates to an empty list.

Non-empty Lists are considered _calls_ to either special forms, macros, or functions. A call has the form +(operator operands*)+.

Special forms are primitives built-in to Clojure that perform core operations. If the operator of a call is a symbol that resolves to the name of a special form, the call is to that special form. Each form discussed individually under <<special_forms#,Special Forms>>.

<<macros#,Macros>> are functions that manipulate forms, allowing for syntactic abstraction. If the operator of a call is a symbol that names a global var that is a macro function, that macro function is called and is passed the _unevaluated_ operand forms. The return value of the macro is then evaluated in its place.

If the operator is not a special form or macro, the call is considered a function call. Both the operator and the operands (if any) are evaluated, from left to right. The result of the evaluation of the operator is then cast to IFn (the interface representing Clojure functions), and invoke() is called on it, passing the evaluated arguments. The return value of invoke() is the value of the call expression. If the function call form has metadata, it may be used by the compiler, but will not be part of the resulting value.
Note that special forms and macros might have other-than-normal evaluation of their arguments, as described in their entries under <<special_forms#,Special Forms>>.

Any object other than those discussed above will evaluate to itself.

''''

*(_load_ classpath-resource ...)* +
*(_load-file_ filename)* +
*(_load-reader_ reader)* +
*(_load-string_ string)*

The above describes the evaluation of a single form. The various load forms will sequentially read and evaluate the set of forms contained in the source. Such sets of forms usually have side effects, often on the global environment, defining functions etc.

The loading functions occur in a temporary context, in which +*ns*+ has a fresh binding. That means that, should any form have an effect on that var (e.g. +in-namespace+), the effect will unwind at the completion of the load. load et al return the value produced by the last expression.

''''

*(_eval_ form)*

Evaluates the form _data structure_ (not text!) and returns the result.

[source,clojure]
----
(eval (list + 1 2 3))
-> 6
----

