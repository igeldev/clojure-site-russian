= REPL и main
Rich Hickey
2015-01-01
:jbake-type: page
:toc: macro
:toc-title: Содержание

ifdef::env-github,env-browser[:outfilesuffix: .adoc]

== REPL и точки входа main

=== Пространство имен clojure.main
Пространство имен `clojure.main` предоставляет функции, которые позволяют запускать программы Clojure с помощью команды `java`, а также открывать сеансы взаимодействия.

=== clojure.main --help 

Точка входа `clojure.main/main` принимает множество аргументов и флагов, как и описано в её справочном сообщении:

[source,clojure]
----
Использование: java -cp clojure.jar clojure.main [init-opt*] [main-opt] [arg*]

Без параметров или аргументов запускает интерактивный REPL (Read-Eval-Print Loop).

init-opt:
-i, --init path Загрузить файл или ресурс
-e, --eval string Вычисляет выражение в строке; выводит значения не равные nil

main-opt:
-r, --repl Запустить REPL
path Запустить скрипт из файла или ресурса
- Запустить скрипт из стандартного ввода
-m, --main Пространство имен, в котором следует искать -main функцию для исполнения
-h, -?, --help Вывести это справочное сообщение и выйти

процесс работы:

- (TODO) Establishes thread-local bindings for commonly set!-able vars
- Входит в пространство имен user
- Устанавливает в *command-line-args* последовательность содержащую аргументы
командной строки после main-opt
- Запускает все init-opt по порядку
- Запускает REPL или скрипт если необходимо

Опции init-opt могут повторяться в произвольном количестве и порядке, но должны быть
перечислены до опций main-opt. Появление опции eval перед запуском repl
заглушает обычное приветствие REPL: "Clojure ~(clojure-version)".

Пути до файлов могут быть абсолютными или относительными в файловой системе или же относительными
к classpath. Classpath-относительные пути должны иметь префикс @ или @/
----

=== Launching a REPL 

The simplest way to launch a Clojure _repl_ is to use the following command line from within Clojure's home directory:

[source,clojure]
----
java -cp clojure.jar clojure.main
----

The REPL prompt shows the name of the current namespace (pass:[*ns*]), which defaults to _user_. 

Several special vars are available when using the REPL:

* *1, *2, *3 - hold the result of the last three expressions that were evaluated
* *e - holds the result of the last exception.

The http://clojure.github.io/clojure/clojure.repl-api.html[clojure.repl] namespace has a number of useful functions for inspecting the source and documentation of available functions:

* http://clojure.github.io/clojure/clojure.repl-api.html#clojure.repl/doc[doc] - prints the docstring for a var given its name
* http://clojure.github.io/clojure/clojure.repl-api.html#clojure.repl/find-doc[find-doc] - prints the docstring for any var whose doc or name matches the pattern
* http://clojure.github.io/clojure/clojure.repl-api.html#clojure.repl/apropos[apropos] - returns a seq of definitions matching a regex
* http://clojure.github.io/clojure/clojure.repl-api.html#clojure.repl/source[source] - prints the source for a symbol
* http://clojure.github.io/clojure/clojure.repl-api.html#clojure.repl/pst[pst] - **p**rint **s**tack **t**race for a given exception or *e by default

=== Launching a Script 

To run a file full of Clojure code as a script, pass the path to the script to `clojure.main` as an argument:

[source,clojure]
----
java -cp clojure.jar clojure.main /path/to/myscript.clj
----

=== Passing arguments to a Script 

To pass in arguments to a script, pass them in as further arguments when launching `clojure.main`:

[source,clojure]
----
java -cp clojure.jar clojure.main /path/to/myscript.clj arg1 arg2 arg3
----

The arguments will be provided to your program as a seq of strings bound to the var `pass:[*command-line-args*]`:

[source,clojure]
----
*command-line-args* => ("arg1" "arg2" "arg3")
----

=== Launching a Socket Server

_**This feature was added in 1.8.0.**_

The Clojure runtime now has the ability to start a socket server at initialization based on system properties. One expected use for this is serving a socket-based REPL, but it also has many other potential uses for dynamically adding server capability to existing programs without code changes.

A socket server will be started for each JVM system property like "clojure.server.<server-name>". The value for this property is an edn map representing the configuration of the socket server with the following properties:

* `server-daemon` - defaults to true, socket server thread doesn't block exit
* `address` - host or address, defaults to loopback
* `port` - positive integer, required
* `accept` - namespaced symbol of function to invoke on socket accept, required
* `args` - sequential collection of args to pass to accept
* `bind-err` - defaults to true, binds `pass:[*err*]` to socket out stream
* `client-daemon` - defaults to true, socket client thread doesn't block exit

Additionally, there is a repl function provided that is slightly customized for use with the socket server in http://clojure.github.io/clojure/clojure.repl-api.html#clojure.core.server/repl[clojure.core.server/repl].

Following is an example of starting a socket server with a repl listener. This can be added to any existing Clojure program to allow it to accept external REPL clients via a local connection to port 5555.

[source,clojure]
----
-Dclojure.server.repl="{:port 5555 :accept clojure.core.server/repl}"
----

An example client you can use to connect to this socket repl is telnet:

[source,clojure]
----
$ telnet 127.0.0.1 5555
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
user=> (println "hello")
hello
----

Also see:

* http://dev.clojure.org/jira/browse/CLJ-1671[CLJ-1671]
* http://dev.clojure.org/display/design/Socket+Server+REPL[Socket REPL design page]

=== Related functions 

Main Entry Point: `http://clojure.github.io/clojure/clojure.main-api.html#clojure.main/main[clojure.main/main]`

Reusable REPL: `http://clojure.github.io/clojure/clojure.main-api.html#clojure.main/repl[clojure.main/repl]`

Allowing set! for the customary REPL vars: `http://clojure.github.io/clojure/clojure.main-api.html#clojure.main/with-bindings[clojure.main/with-bindings]`
