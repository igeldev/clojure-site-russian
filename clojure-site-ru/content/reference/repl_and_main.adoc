= REPL и main
Rich Hickey
2015-01-01
:jbake-type: page
:toc: macro
:toc-title: Содержание

ifdef::env-github,env-browser[:outfilesuffix: .adoc]

== REPL и точки входа main

=== Пространство имен clojure.main
Пространство имен `clojure.main` предоставляет функции, которые позволяют запускать программы Clojure с помощью команды `java`, а также открывать сеансы взаимодействия.

=== clojure.main --help 

Точка входа `clojure.main/main` принимает множество аргументов и флагов, как и описано в её справочном сообщении:

[source,clojure]
----
Использование: java -cp clojure.jar clojure.main [init-opt*] [main-opt] [arg*]

Без параметров или аргументов запускает интерактивный REPL (Read-Eval-Print Loop) - цикл считывания выражений и выдачи результатов.

init-opt:
-i, --init path Загрузить файл или ресурс
-e, --eval string Вычисляет выражение в строке; выводит значения не равные nil

main-opt:
-r, --repl Запустить REPL
path Запустить скрипт из файла или ресурса
- Запустить скрипт из стандартного ввода
-m, --main Пространство имен, в котором следует искать -main функцию для исполнения
-h, -?, --help Вывести это справочное сообщение и выйти

процесс работы:

- (TODO) Establishes thread-local bindings for commonly set!-able vars
- Входит в пространство имен user
- Устанавливает в *command-line-args* последовательность содержащую аргументы
командной строки после main-opt
- Запускает все init-opt по порядку
- Запускает REPL или скрипт если необходимо

Опции init-opt могут повторяться в произвольном количестве и порядке, но должны быть
перечислены до опций main-opt. Появление опции eval перед запуском repl
заглушает обычное приветствие REPL: "Clojure ~(clojure-version)".

Пути до файлов могут быть абсолютными или относительными в файловой системе или же относительными
к classpath. Classpath-относительные пути должны иметь префикс @ или @/
----

=== Запуск REPL

Простейший способ запустить _repl_ - использование следующей команды в домашней директории Clojure:

[source,clojure]
----
java -cp clojure.jar clojure.main
----

Подсказка REPL покажет текущее пространство имен (pass:[*ns*]), по-умолчанию - _user_.

В REPL доступны несколько специальных переменных:

* *1, *2, *3 - хранят результат последних трех вычисленных выражений
* *e - хранит последнее исключение.

Пространство имен http://clojure.github.io/clojure/clojure.repl-api.html[clojure.repl] содержит несколько полезных функций для изучения исходного кода и документации доступных функций:

* http://clojure.github.io/clojure/clojure.repl-api.html#clojure.repl/doc[doc] - печатает информацию о переменной по её имени
* http://clojure.github.io/clojure/clojure.repl-api.html#clojure.repl/find-doc[find-doc] - печатает информацию о переменных, чья документация или имя подходит под регулярное выражение
* http://clojure.github.io/clojure/clojure.repl-api.html#clojure.repl/apropos[apropos] - возвращает последовательность определений, подходящих под регулярное выражение
* http://clojure.github.io/clojure/clojure.repl-api.html#clojure.repl/source[source] - печатает исходный код для заданного знака
* http://clojure.github.io/clojure/clojure.repl-api.html#clojure.repl/pst[pst] - печатает стек вызовов (**p**rint **s**tack **t**race) для данного исключения, по-умолчанию - *e 

=== Запуск скрипта

Чтобы выполнить скрипт-файл с Clojure кодом, нужно передать путь до скрипта в `clojure.main` как аргумент:

[source,clojure]
----
java -cp clojure.jar clojure.main /path/to/myscript.clj
----

=== Передача аргументов в скрипт

Чтобы передать аргументы в скрипт, их нужно записать как конечные аргументы при запуске `clojure.main`:

[source,clojure]
----
java -cp clojure.jar clojure.main /path/to/myscript.clj arg1 arg2 arg3
----

Аргументы будут предоставлены в вашей программе как последовательность строк, привязанных к переменной `pass:[*command-line-args*]`:

[source,clojure]
----
*command-line-args* => ("arg1" "arg2" "arg3")
----

=== Launching a Socket Server

_**This feature was added in 1.8.0.**_

The Clojure runtime now has the ability to start a socket server at initialization based on system properties. One expected use for this is serving a socket-based REPL, but it also has many other potential uses for dynamically adding server capability to existing programs without code changes.

A socket server will be started for each JVM system property like "clojure.server.<server-name>". The value for this property is an edn map representing the configuration of the socket server with the following properties:

* `server-daemon` - defaults to true, socket server thread doesn't block exit
* `address` - host or address, defaults to loopback
* `port` - positive integer, required
* `accept` - namespaced symbol of function to invoke on socket accept, required
* `args` - sequential collection of args to pass to accept
* `bind-err` - defaults to true, binds `pass:[*err*]` to socket out stream
* `client-daemon` - defaults to true, socket client thread doesn't block exit

Additionally, there is a repl function provided that is slightly customized for use with the socket server in http://clojure.github.io/clojure/clojure.repl-api.html#clojure.core.server/repl[clojure.core.server/repl].

Following is an example of starting a socket server with a repl listener. This can be added to any existing Clojure program to allow it to accept external REPL clients via a local connection to port 5555.

[source,clojure]
----
-Dclojure.server.repl="{:port 5555 :accept clojure.core.server/repl}"
----

An example client you can use to connect to this socket repl is telnet:

[source,clojure]
----
$ telnet 127.0.0.1 5555
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
user=> (println "hello")
hello
----

Also see:

* http://dev.clojure.org/jira/browse/CLJ-1671[CLJ-1671]
* http://dev.clojure.org/display/design/Socket+Server+REPL[Socket REPL design page]

=== Related functions 

Main Entry Point: `http://clojure.github.io/clojure/clojure.main-api.html#clojure.main/main[clojure.main/main]`

Reusable REPL: `http://clojure.github.io/clojure/clojure.main-api.html#clojure.main/repl[clojure.main/repl]`

Allowing set! for the customary REPL vars: `http://clojure.github.io/clojure/clojure.main-api.html#clojure.main/with-bindings[clojure.main/with-bindings]`
