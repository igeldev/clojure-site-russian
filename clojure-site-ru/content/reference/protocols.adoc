= Протоколы
Rich Hickey
2015-01-01
:type: reference
:toc: macro
:toc-title: Содержание
:icons: font
:prevpagehref: multimethods
:prevpagetitle: Multimethods and Hierarchies
:nextpagehref: metadata
:nextpagetitle: Metadata

ifdef::env-github,env-browser[:outfilesuffix: .adoc]

toc::[]

== Мотивация

Clojure написана в терминах абстракций. Существуют абстракции для последовательностей, коллекций, вызываемых функций и другие. Также Clojure поддерживает множество реализаций этих абстракций. Эти абстракции определены интерфейсами Java, а реализации - Java-классами. И хотя такой подход и ускоряет начальную загрузку языка, это оставляет Clojure без аналогичных абстракций и низкоуровневых средств реализации. <<protocols#,Протоколы>> и <<datatypes#,типы данных>> добавляют мощные и гибкие механизмы для объявления абстракций и структур данных гораздо более удобные, чем возможности платформы Java.

Существуют следующие причины создания протоколов:

* Предоставить высокопроизводительную конструкцию с динамическим полиморфизмом как альтернативу интерфейсам
* Поддерживать лучшее из интерфесов
** только спецификация, без реализации
** один тип может реализовывать несколько протоколов
* При этом избежать некоторых недостатков
** Какие интерфейсы реализовываются - это выбор, осуществляющийся автором во время проектирования и это не может быть расширено позже (хотя вставки интерфейсов могут в конечном итоге обратиться к этому)
** реализация интерфейса создает отношения между классами и иерархию
* Избежать "проблемы выражения" позволив независимо расширять множество типов, протоколов и реализаций протоколов
** делать это без оберток и адаптеров
* Поддерживать 90% случаев мультиметодов во время предоставления высокоуровневой абстракции/организации

[ВНИМАНИЕ]
Протоколы были добавлены в Clojure 1.2.

== Основы

Протокол - это именованное множество методов и их сигнатур, определенных с помощью http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/defprotocol[defprotocol]:

[source,clojure]
----
(defprotocol AProtocol
  "A doc string for AProtocol abstraction"
  (bar [a b] "bar docs")
  (baz [a] [a b] [a b c] "baz docs"))
----

* Никаких реализаций не предосталвяется
* Комментарии могут специфицировать как протокол, так и функции
* Код выше порождает множество полиморфичных функций и объект протокола
** все они будут принадлежать пространству имен, в котором было выполнено объявление протокола
* Получаемые функции отправляют по типу их первого аргумента и поэтому должны иметь хотя бы один аргумент
* defprotocol - динамический и не требует AOT-компиляции.

http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/defprotocol[defprotocol] will automatically generate a corresponding interface, with the same name as the protocol, i.e. given a protocol my.ns/Protocol, an interface my.ns.Protocol. The interface will have methods corresponding to the protocol functions, and the protocol will automatically work with instances of the interface.

Note that you do not need to use this interface with http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/deftype[deftype] , http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/defrecord[defrecord] , or http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/reify[reify], as they support protocols directly:

[source,clojure]
----
(defprotocol P
  (foo [x])
  (bar-me [x] [x y]))

(deftype Foo [a b c]
  P
  (foo [x] a)
  (bar-me [x] b)
  (bar-me [x y] (+ c y)))

(bar-me (Foo. 1 2 3) 42)
= > 45

(foo
 (let [x 42]
   (reify P
     (foo [this] 17)
     (bar-me [this] x)
     (bar-me [this y] x))))

> 17
----

A Java client looking to participate in the protocol can do so most efficiently by implementing the protocol-generated interface.

External implementations of the protocol (which are needed when you want a class or type not in your control to participate in the protocol) can be provided using the http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/extend[extend] construct:

[source,clojure]
----
(extend AType
  AProtocol
   {:foo an-existing-fn
    :bar (fn [a b] ...)
    :baz (fn ([a]...) ([a b] ...)...)}
  BProtocol
    {...}
...)
----

extend takes a type/class (or interface, see below), a one or more protocol + function map (evaluated) pairs.

* Will extend the polymorphism of the protocol's methods to call the supplied functions when an AType is provided as the first argument
* Function maps are maps of the keywordized method names to ordinary fns
** this facilitates easy reuse of existing fns and maps, for code reuse/mixins without derivation or composition
* You can implement a protocol on an interface
** this is primarily to facilitate interop with the host (e.g. Java)
** but opens the door to incidental multiple inheritance of implementation
*** since a class can inherit from more than one interface, both of which implement the protocol
*** if one interface is derived from the other, the more derived is used, else which one is used is unspecified.
* The implementing fn can presume first argument is instanceof AType
* You can implement a protocol on _**nil**_
* To define a default implementation of protocol (for other than nil) just use Object

Protocols are fully reified and support reflective capabilities via http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/extends%3F[extends?] , http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/extenders[extenders] , and http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/satisfies%3F[satisfies?] .

* Note the convenience macros http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/extend-type[extend-type] , and http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/extend-protocol[extend-protocol]
* If you are providing external definitions inline, these will be more convenient than using *extend* directly

[source,clojure]
----
(extend-type MyType
  Countable
    (cnt [c] ...)
  Foo
    (bar [x y] ...)
    (baz ([x] ...) ([x y zs] ...)))

  ;expands into:

(extend MyType
  Countable
   {:cnt (fn [c] ...)}
  Foo
   {:baz (fn ([x] ...) ([x y zs] ...))
    :bar (fn [x y] ...)})
----
