= Переменные
Rich Hickey
2015-01-01
:jbake-type: page
:toc: macro
:toc-title: Содержание

ifdef::env-github,env-browser[:outfilesuffix: .adoc]

toc::[]

== Переменные и глобальное окружение

Clojure - прикладной язык программирования, который признает необходимость время от времени держать постоянные ссылки на изменяемые значения и предлагает для этого 4 различных механизма - переменные, <<refs#,ссылки>>, <<agents#,агенты>> и <<atoms#,атомы>>. Переменные позволяют ссылаться на изменяемое хранилище, которое может быть динамически заменено (на новое хранилище) для отдельного потока. Каждая переменная может (но не должна) иметь некоторую "главную" связь, которая будет использоваться потоками, не имеющими своей отдельной связи для данной переменной. Таким образом, значение переменной - это значение в хранилище, с которым связана эта переменная в текущем потоке, либо значение в главном хранилище.

Специальная форма _**def**_ создает (и <<vars#interning,помещает в пул>>) переменную. Если эта переменная не существовала и не было предоставлено начального значения - она будет несвязанной:

[source,clojure]
----
user=> (def x)
.'user/x
user=> x
java.lang.IllegalStateException: Var user/x is unbound.
----

Если начальное значение предоставлено - оно помещается в главное хранилище, связанное с переменной (даже если с переменная уже была связанна с некоторым хранилищем).

[source,clojure]
----
user=> (def x 1)
.'user/x

user=> x
1
----

По-умолчанию переменные являются статическими, но они могут быть помечены как динамические чтобы разрешить переопределение связанного хранилища для отдельного потока. Это осуществляется с помощью макроса http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/binding[binding]. Внутри каждого потока динамические переменные подчиняются правилам стека:

[source,clojure]
----
user=> (def ^:dynamic x 1)
user=> (def ^:dynamic y 1)
user=> (+ x y)
2

user=> (binding [x 2 y 3]
         (+ x y))
5

user=> (+ x y)
2
----

Связи, созданные с помощью _**binding**_ не будут видны другим потокам. Также эти связи могут быть переопределены, что позволяет вложенным контекстам общаться с кодом, находящимся выше в стеке вызовов. Эта возможность доступна только после того, как для переменной установлен мета-тег _**dynamic**_, как в примере выше. Если необходимо переопределить статические переменные в некотором контексте - для этого Clojure (начиная с версии 1.3) предоставляет функции http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/with-redefs[with-redefs] и http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/with-redefs-fn[with-redefs-fn].

Функции определенные с помощью http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/defn[defn] хранятся в переменных, что позволяет переопределять функции при исполнении программы. Также это позволяет применять подходы аспектно-ориентированного и контекстно-ориентированного программирования. Например, вы можете добавить в функцию журналирование только для некоторых контекстов или потоков.

[[set]]
=== (*set!* var-symbol expr)

Assignment special form.

When the first operand is a symbol, it must resolve to a global var. The value of the var's current thread binding is set to the value of expr. Currently, it is an error to attempt to set the root binding of a var using set!, i.e. var assignments are thread-local. In all cases the value of expr is returned.

Note - _you cannot assign to function params or local bindings. Only Java fields, Vars, Refs and Agents are mutable in Clojure_.

Using <<java_interop#set,set>> for Java fields is documented in <<java_interop#set,Java Interop>>.

[[Interning]]
=== Interning 
The Namespace system maintains global maps of symbols to Var objects _(see <<namespaces#,Namespaces>>)_. If a _**def**_ expression does not find an interned entry in the current namespace for the symbol being def-ed, it creates one, otherwise it uses the existing Var. This find-or-create process is called interning. This means that, unless they have been unmap-ed, Var objects are stable references and need not be looked up every time. It also means that namespaces constitute a global environment in which, as described in <<evaluation#,Evaluation>>, the compiler attempts to resolve all free symbols as Vars.

The <<special_forms#var,var>> special form or the `pass:[#']` reader macro _(see <<reader#,Reader>>)_ can be used to get an interned Var object instead of its current value.

[[local-vars]]
=== Non-interned Vars

It is possible to create vars that are not interned by using http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/with-local-vars[with-local-vars]. These vars will not be found during free symbol resolution, and their values have to be accessed manually. But they can serve as useful thread-local mutable cells.

[[related]]
=== Related functions 

[%hardbreaks]
Variants of _**def**_: http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/defn[defn] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/defn-[defn-] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/definline[definline] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/defmacro[defmacro] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/defmethod[defmethod] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/defmulti[defmulti] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/defonce[defonce] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/defstruct[defstruct]
Working with interned Vars: http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/declare[declare] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/intern[intern] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/binding[binding] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/find-var[find-var] <<special_forms#var#,var>>
Working with Var objects: http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/with-local-vars[with-local-vars] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/var-get[var-get] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/var-set[var-set] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/alter-var-root[alter-var-root] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/var?[var?] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/with-redefs[with-redefs] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/with-redefs-fn[with-redefs-fn]
Var validators: http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/set-validator[set-validator] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/get-validator[get-validator]
Common Var metadata: http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/doc[doc] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/find-doc[find-doc] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/test[test]
