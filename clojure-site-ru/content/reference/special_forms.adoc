= Специальные Формы
Rich Hickey
2016-02-09
:type: reference
:toc: macro
:toc-title: Содержание
:icons: font
:prevpagehref: evaluation
:prevpagetitle: Evaluation
:nextpagehref: macros
:nextpagetitle: Macros

ifdef::env-github,env-browser[:outfilesuffix: .adoc]

toc::[]

[[def]]
== (_def_ symbol init?)

Создает и размещает или распологает глобальную переменную с именем symbol в пространстве имен, находаемся в (_**pass:[*ns*]**_) текущего пространства имен. Если init предоставлен, он вычисляется, и начальная привязка переменной устанавливается в результат. Если init нет, начальная привязка не изменяется. _**def**_ всегда применяется к начальной привязке, даже если переменная привязана к потоку в момент когда _**def**_ вызывается. _**def**_ производит переменную саму по себе _(не её значение)_. Выбрасывает исключение если знак уже существует в пространстве имен и не соответствует переменной. С версии 1.3, _**def**_ имеет необязательный переметр doc-string: (_def_ symbol doc-string? init?).

Любые метаданные знака будут вычислены и станут метаданными переменной. Есть несколько ключей метаданных, имеющих специальное значение:

* _**:private**_
+
логическое значение, обозначающее контроль доступа к переменной. Если этого ключа нет, по-умолчанию будет применен доступ public (также, если бы было :private false).
* _**:doc**_
+
строка, содержащая короткую документацию для содержимого переменной
* _**:test**_
+
функция без аргументов которая использует assert чтобы проверить различные операции. Переменная будет доступна во время вычисления литерала fn в метаданных.
* _**:tag**_
+
знка именующий класс или объект Class который обозначает Java-тип объекта в переменной, или возвращаемого значения, если объект является функцией.

Также компилятор будет распологать следующие метаданные в переменной:

* _**:file**_ строка
* _**:line**_ целое число
* _**:name**_ простой знак
* _**:ns**_ пространство имен в которое переменная была включена
* _**:macro**_ true если переменная именует макрос
* _**:arglists**_ список векторов форм аргументов, так как они были переданы в defn

Метаданные переменной могут быть использованы для различных целей. Рассмотрим использование ключей с уточненным пространством имен (например :myns/foo) чтобы избежать конфликтов.

[source,clojure]
----
(defn
 ^{:doc "mymax [xs+] gets the maximum value in xs using > "
   :test (fn []
             (assert (= 42  (mymax 2 42 5 4))))
   :user/comment "this is the best fn ever!"}
  mymax
  ([x] x)
  ([x y] (if (> x y) x y))
  ([x y & more]
   (reduce mymax (mymax x y) more)))

user=> (meta #'mymax)
  {:name mymax,
   :user/comment "this is the best fn ever!",
   :doc "mymax [xs+] gets the maximum value in xs using > ",
   :arglists ([x] [x y] [x y & more])
   :file "repl-1",
   :line 126,
   :ns #<Namespace user >,
   :test #<user$fn__289 user$fn__289@20f443 >}
----

Многие макросы расширяют в _**def**_ (например _**defn**_, _**defmarco**_) и таким образом также используют метаданные для получаемого значения из знака использованного как имя.

Использование def для модификации корневого значения переменной не на верхнем уровне обычно означает, что вы используете переменную как изменяемую глобальную и рассматривается как плохой стиль. Рассмотрите использование привязки чтобы предоставить потоково-локальное значение для переменной или передачу ссылки или агента в переменную и использование транзакций или действий для изменения.

[[if]]
== (_if_ test then else?)

Вычисляет test. Если получается не *nil* или *false*, вычисляет и возвращает then, иначе вычисляет и возвращает else. Если else не предоставлен, вместо него возвращается *nil*. Все другие условные выражения в Clojure основаны на той же логике, т.е. *nil* и *false* представляют логическую ЛОЖЬ, остальное - логическую ИСТИНУ. _**if**_ выполняет проверку условия, представленного в виде Java-метода, возвращающего значение без преобзразования в Boolean. Заметим, что _**if**_ не проверяет произвольные значения java.lang.Boolean, только *false* (Java Boolean.FALSE) т.е. если вы создали свои обертки Boolean удостовертесь, что используете Bolean/valueOf, а не Boolean конструктуры.

[[do]]
== (_do_ exprs*)

Вычисляет выражения по порядку и возвращает последнее значение. Если выражений нет, возвращает nil.

[[let]]
== (_let_ [bindings* ] exprs*)

binding => binding-form init-expr

Вычисляет выражения в лексическом контексте, в котором знаки из binding-form привязаны к их соответствующим значениям init-expr. Привязки последовательны и следующая может видеть предыдущие. Выражения содержатся неявно. Если знак привязки аннотирован тегом метаданных, компилятор будет пытаться разрешить тег в имя класса и предположить, что тип в последующих ссылках к привязке. Простейшая форма привязки - это знак которй привязывается к целому init-expr:

[source,clojure]
----
(let [x 1
      y x]
  y)
-> 1
----

См. <<special_forms#binding-forms#,Формы привязки>> чтобы узнать больше о формах привязки.

*Локальные привязки, созданные с помощью let не являются переменными. Однажды созданные, их значения никогда не меняются!*

[[quote]]
== (_quote_ form)

Порождает невычисленную форму.

[source,clojure-repl]
----
user=> '(a b c)
(a b c)
----

Заметим, что не будет сделано попыток вызвать функцию a. Возвратится список из 3 знаков.

[[var]]
== (_var_ symbol)

symbol должен разрешаться в переменную и тогда объект переменная _(не её значение)_ будет возвращен. Макрос #'x разворачивается в (var x).

[[fn]]
== (_fn_ name? [params* ] exprs*)
== (_fn_ name? ([params* ] exprs*)+)

params => positional-params* , или positional-params* & rest-param +
positional-param => binding-form +
rest-param => binding-form +
name => symbol

Определяет функцию (fn). Функции объекты, реализующие интерфейс IFn. Этот интерфейс определяет функцию invoke(), которая перегружается с арностью от 0 до 20. Один объект fn может реализовывать один или более метод invoke() и быть таким образом перегруженным по арности. Одна и только одна перегрузка может принимать множество параметров, если через амперсанд объявлены rest-param. Когда такая точка входа со множеством параметров вызывается с большим количеством параметров, они будут собраны в последовательность rest-param. Если количество аргументов не превышает positional params, rest-params будут равны nil.

Первая форма, определяет fn с одним invoke методом. Вторая определяет fn с одним или более перегруженными invoke методами. Арность перегрузок должна быть ясна. Иначе результатом выражения будет один fn объет.

Выражения вычисляются в окружении, в котором параметры привязываются к аргументам. Выражения exprs оборачиваются в неявный do. Если предоставлен знак name, он привязывается внутри объявления функции к объекту функции, позволяя самовызов, даже в анонимной функции. Если знак param аннотирован метаданными, компилятор будет пытаться разрешить тег в имя класса и предположить этот тип в последующих ссылок на связывание.

[source,clojure]
----
(def mult
  (fn this
      ([] 1)
      ([x] x)
      ([x y] (* x y))
      ([x y & more]
          (apply this (this x y) more))))
----
Заметим, что именованные функции, такие как mult обычно определяются с помощью defn, который раскрывается в конструкцию, похожую на представленную выше.

Функции определяют точку рекурсии вверху функции, с арностью равной количеству параметров _включая rest param, если он есть_. См. recur.

Функции реализуют Java-интерфейсы Callable, Runnable и Comparator.

*__После 1.1__*

Функции поддерживают определение пред- и постустовия времени выполенения.

Синтаксис для определения функции следующий:

== (_fn_ name? [params* ] condition-map? exprs*)
== (_fn_ name? ([params* ] condition-map? exprs*)+)

Расширение синтаксиса также применяется к defn и другим макросам, которые разворачиваются в fn формы.

Заметим: если единственная форма после вектора параметров - соответствие, оно рассматривается как тело функции, а не как соответствие условий.

Соответствие условий (condition-map) может быть использовано для определения перд- и постусловие для функции. Это одна из следующих форм:

[%hardbreaks]
{:pre [pre-expr*]
:post [post-expr*]}

Где ключ опционален. Условия также могут быть предоставлены как метаданные списка аргументов.

**pre-expr** и **post-expr** - это логические выражения, которые могут ссылаться на параметры функции. В дополнении, **%** может быть использовано в post-expr чтобы сослаться на возвращенное значение. Если любое из условий вычисляется в false и **pass:[*assert*]** - true, бросается assertion failure исключение.

Пример:
[source,clojure]
----
(defn constrained-sqr [x]
    {:pre  [(pos? x)]
     :post [(> % 16), (< % 225)]}
    (* x x))
----

См. <<special_forms#binding-forms#,Формы привязки>> чтобы получить больше информации о формах привязки.

[[loop]]
== (_loop_ [bindings* ] exprs*)

loop is exactly like let, except that it establishes a recursion point at the top of the loop, with arity equal to the number of bindings. See recur.

[[recur]]
== (_recur_ exprs*)

Evaluates the exprs in order, then, in parallel, rebinds the bindings of the recursion point to the values of the exprs. If the recursion point was a fn method, then it rebinds the params. If the recursion point was a loop, then it rebinds the loop bindings. Execution then jumps back to the recursion point. The recur expression must match the arity of the recursion point exactly. In particular, if the recursion point was the top of a variadic fn method, there is no gathering of rest args - a single seq (or null) should be passed. recur in other than a tail position is an error.

Note that recur is the only non-stack-consuming looping construct in Clojure. There is no tail-call optimization and the use of self-calls for looping of unknown bounds is discouraged. recur is functional and its use in tail-position is verified by the compiler.

[source,clojure]
----
(def factorial
  (fn [n]
    (loop [cnt n acc 1]
       (if (zero? cnt)
            acc
          (recur (dec cnt) (* acc cnt))))))
----

[[throw]]
== (_throw_ expr)

The expr is evaluated and thrown, therefore it should yield an instance of some derivee of Throwable.

[[try]]
== (_try_ expr* catch-clause* finally-clause?)

catch-clause -> (_catch_ classname name expr*) +
finally-clause -> (_finally_ expr*)

The exprs are evaluated and, if no exceptions occur, the value of the last is returned. If an exception occurs and catch clauses are provided, each is examined in turn and the first for which the thrown exception is an instance of the named class is considered a matching catch clause. If there is a matching catch clause, its exprs are evaluated in a context in which name is bound to the thrown exception, and the value of the last is the return value of the function. If there is no matching catch clause, the exception propagates out of the function. Before returning, normally or abnormally, any finally exprs will be evaluated for their side effects.

[[monitor-enter]]
== (_monitor-enter_ x)

[[monitor-exit]]
== (_monitor-exit_ x)

These are synchronization primitives that should be avoided in user code. Use the _**locking**_ macro.

== Other Special Forms

anchor:.[]
anchor:new[]
The special forms <<java_interop#dot,dot ('.')>>, <<java_interop#new,new>>, and <<java_interop#set,set!>> of fields are described in the <<java_interop#,Java Interop>> section of the reference.

anchor:set![]
<<vars#set%21,set!>> of vars is described in the <<vars#,Vars>> section of the reference.

[[binding-forms]]
== Binding Forms (Destructuring)

Clojure supports abstract structural binding, often called destructuring, in let binding lists, fn parameter lists, and any macro that expands into a let or fn. The basic idea is that a binding-form can be a data structure literal containing symbols that get bound to the respective parts of the init-expr. The binding is abstract in that a vector literal can bind to anything that is sequential, while a map literal can bind to anything that is associative.

=== Vector binding destructuring

Vector binding-exprs allow you to bind names to parts of _sequential_ things (not just vectors), like vectors, lists, seqs, strings, arrays, and anything that supports nth. The basic sequential form is a vector of binding-forms, which will be bound to successive elements from the init-expr, looked up via nth. In addition, and optionally, & followed by a binding-forms will cause that binding-form to be bound to the remainder of the sequence, i.e. that part not yet bound, looked up via http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/nthnext[nthnext] .

Finally, also optional, :as followed by a symbol will cause that symbol to be bound to the entire init-expr:

[source,clojure]
----
(let [[a b c & d :as e] [1 2 3 4 5 6 7]]
  [a b c d e])

->[1 2 3 (4 5 6 7) [1 2 3 4 5 6 7]]
----

These forms can be nested:

[source,clojure]
----
(let [[[x1 y1][x2 y2]] [[1 2] [3 4]]]
  [x1 y1 x2 y2])

->[1 2 3 4]
----

Strings work too:

[source,clojure]
----
(let [[a b & c :as str] "asdjhhfdas"]
  [a b c str])

->[\a \s (\d \j \h \h \f \d \a \s) "asdjhhfdas"]
----

=== Map binding destructuring

Map binding-forms allow you to bind names to parts of _associative_ things (not just maps), like maps, vectors, string and arrays (the latter three have integer keys). It consists of a map of binding-form-key pairs, each symbol being bound to the value in the init-expr at the key. In addition, and optionally, an _**:as**_ key in the binding form followed by a symbol will cause that symbol to be bound to the entire init-expr. Also optionally, an _**:or**_ key in the binding form followed by another map may be used to supply default values for some or all of the keys if they are not found in the init-expr:

[source,clojure]
----
(let [{a :a, b :b, c :c, :as m :or {a 2 b 3}}  {:a 5 :c 6}]
  [a b c m])

->[5 3 6 {:c 6, :a 5}]
----

It is often the case that you will want to bind same-named symbols to the map keys. The _**:keys**_ directive allows you to avoid the redundancy:

[source,clojure]
----
(let [{fred :fred ethel :ethel lucy :lucy} m] ...
----

can be written:

[source,clojure]
----
(let [{:keys [fred ethel lucy]} m] ...
----

As of Clojure 1.6, you can also use prefixed map keys in the map destructuring form:

[source,clojure]
----
(let [m {:x/a 1, :y/b 2}
      {:keys [x/a y/b]} m]
  (+ a b))

-> 3
----

As shown above, in the case of using prefixed keys, the bound symbol name will be the same as the right-hand side of the prefixed key. You can also use auto-resolved keyword forms in the _**:keys**_ directive:

[source,clojure]
----
(let [m {::x 42}
      {:keys [::x]} m]
  x)

-> 42
----

There are similar _**:strs**_ and _**:syms**_ directives for matching string and symbol keys, the latter also allowing prefixed symbol keys since Clojure 1.6.

=== Nested destructuring

Since binding forms can be nested within one another arbitrarily, you can pull apart just about anything:

[source,clojure]
----
(let [{j :j, k :k, i :i, [r s & t :as v] :ivec, :or {i 12 j 13}}
      {:j 15 :k 16 :ivec [22 23 24 25]}]
  [i j k r s t v])

-> [12 15 16 22 23 (24 25) [22 23 24 25]]
----
